[{"authors":["admin"],"categories":null,"content":"还没想好呢\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://johnjim0816.github.io/author/jiang-ji/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/jiang-ji/","section":"authors","summary":"还没想好呢","tags":null,"title":"Jiang Ji","type":"authors"},{"authors":[],"categories":["机器学习"],"content":"本文主要区分机器学习中的三种数据集，尤其是验证集和测试集，并介绍常用的交叉验证训练方法。\nTraining Set 训练集，即用于训练模型内参数(fit the model)的数据集。\nTesting Set 即测试集，在使用训练集调整参数之后，使用测试集来评价模型泛化能力。\nValidation Set 实际上使用测试集评价模型泛化能力之后并不意味着机器学习任务就此完成，最后还需要使用一个没有见过的数据集来判断模型是否work。在Kaggle中，Testing Set分为Public和Private Testing Set，Public就是用于评价模型泛化能力的通常意义上的测试集，而Private则是未知分布的测试集，决定最终排名的正是Private而不是Public测试。但是，通常训练好的模型在Public Testing Set上的error并不能代表模型在Private Testing Set上的error。例如，通过训练集训练出的model的error为0.1，那么在Public Testing Set中error一般大于且接近于0.1，而在Private Testing Set就不确定了，也可能大于0.5，也可能小于0.1。\n形象说来训练集就像是课本，学生通过课本学习知识，Public测试集就是平时的测验，而Private才是最终的高考。但是平时的测验往往只涵盖课本知识的一小部分，而高考则考查得更为全面，这也是为什么有些同学平时测验很好但是高考失常，平时较差但是高考成了黑马的原因之一。如何让Public测试集，即平时的测验变成有水准的模拟考试，从而反映学生在高考的水平呢？一种方法就是在学生学习课本知识的过程中增加平时作业。\n即可以从训练集中随机分出一部分作为验证集(Validation Set)，如下： 在训练集中调整参数以后，比如训练model1，model2，model3，将模型在验证集上测试，选出error最小的比如model1，然后用model1在整个Training Set上再训一次，然后使用Testing Set(Public)评价其泛化能力，这样此时在Testing Set(Public)上的结果就能跟最终的Private Testing Set相近了。\n交叉验证 其实上面的验证集也只是从Training Set中抽出了一次，也就是只根据课本知识的某一部分布置了作业，想要得到最终好的结果就需要进行多组实验。交叉验证的做法就是将数据集分为近似均等且不相交的$k$份，如下： $$ D=D_1 \\or D_2 \\or \u0026hellip; \\or D_k \\\nD_i \\neq D_i (i \\neq j) $$\n然后依次取其中一份作为验证集，其余作为训练集进行训练，然后求得error的均值作为用于评价来调整模型参数，如下：\n","date":1591000115,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1591000115,"objectID":"ec5cd9b0d6f3939549a502bc415a4762","permalink":"https://johnjim0816.github.io/june/01/1/monday/153/post/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/","publishdate":"2020-06-01T16:28:35+08:00","relpermalink":"/june/01/1/monday/153/post/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/","section":"post","summary":"本文主要区分机器学习中的三种数据集，尤其是验证集和测试集，并","tags":["机器学习"],"title":"训练集(Train),验证集(Validation)和测试集(Test Sets)以及交叉验证法","type":"post"},{"authors":[],"categories":["python3"],"content":"import声明即用于导入模块，比如import numpy as np，但是涉及复杂工程目录时容易搞得稀里糊涂，于是我专门使用了python3.7来测试并解决import相关问题。\n基本定义   module：即模块，也就是中各种.py文件，模块名就是文件名\n  built-in-module：即内置模块，就是在安装python的时候系统编译在python解释器中的，比如numpy\n  package：任何包含__init__.py文件的文件夹就是一个package。注意根据 python document，在python3.3以上中，即使没有__init__.py，文件夹也被自动视作一个package\n  object：即对象，在python中，对象可以是函数，类以及变量等。\n  import与sys.path 如果import导入了一个module，就能运行该module中的所有代码。导入package时，会运行package目录下的__init__.py，然后通过__init__.py运行package目录下的所有module，__init__.py可以是空的，前面讲到在python3.3以上，__init__.py可以没有。\nimport会自动在sys.path包含的目录中寻找相应的模块或者包，在一个.py脚本被运行时，sys.path会初始化包含以下目录：\n PYTHONPATH，即常说的系统环境变量PATH 默认安装的模块目录，比如numpy就在此目录中 .py脚本所在的目录，这一点根据脚本所在的目录不同是可以变化的。  常用的import方式 常用的import方式有四种：\nimport \u0026lt;package\u0026gt; import \u0026lt;module\u0026gt; from \u0026lt;package\u0026gt; import \u0026lt;module or subpackage or object\u0026gt; from \u0026lt;module\u0026gt; import \u0026lt;object\u0026gt;  当然还有\nimport \u0026lt;module\u0026gt; as # 比如 import numpy as np import \u0026lt;object\u0026gt; as  场景1：导入系统以及同级目录下的模块 对于以下的工程目录：\ntest/ # 跟目录 packA/ # package packA subA/ # subpackage subA __init__.py sa1.py sa2.py __init__.py a1.py a2.py packB/ # package packB (implicit namespace package) b1.py b2.py other.py start.py  要在start.py中导入系统numpy模块，以及同级目录下的other模块，只需要：\nimport numpy import numpy as np # 通常将numpy重命名为np import other  然后运行start.py脚本\n场景2:导入子目录下的模块 如果需要在start.py中导入a1.py，b1.py以及sa1.py模块，只需要在start.py中：\nimport packA.a1 import packB.b1 import packA.subA.sa1  如果只需要导入比如a1.py某个函数a1_func()，只需要：\nfrom packA.a1 import a1_func() from packA.subA.sa1 import sa1_func() # 跟上面同理  注意在start.py和在a1.py导入sa1.py是不同的，在a1.py需要：\nimport subA.sa1 from subA.sa1 import sa1_func() from subA import sa2  因为运行a1.py时sys.path的相应目录已经改变，只包含a1.py脚本所在的目录。而对于python3，在start.py是不能跨越子目录直接导入sa1.py的，比如from subA import sa1，但是在python2中可以，下面做个简单的总结：\n   运行 from packA.subA import sa1 from subA import sa1     start.py OK Py2 OK, Py3 fail (subA not in test/)   a1.py fail (packA not in test/packA/) OK    场景3:导入父目录下的模块 如果需要在a1.py中导入父目录下other.py或者是packB目录下的b1.py，此时就需要对sys.path作出修改了，因为运行a1.py时sys.path包含a1.py所在的目录packA，并不包含目录packB以及父目录test。 修改sys.path需要用到sys以及os模块，首先需要知道怎么获取当前目录以及父目录，在a1.py中如下：\ncurrent_path=os.path.dirname(__file__) #当前a1.py所在的目录packA parent_path=os.path.dirname(os.path.dirname(__file__)) #当前a1.py所在的父目录或者说上级目录test p_parent_path=os.path.dirname(os.path.dirname(os.path.dirname(__file__))) ##获取上上级目录  下面修改sys.path，对于在a1.py中导入父目录下other.py或者是packB目录下的b1.py，只需要将parent_path加入到```sys.path``即可，\nsys.path.append(parent_path)  然后就可以导入other.py以及b1.py了，完整代码如下：\nimport sys import os # print(os.getcwd()) # sys.path.append(os.getcwd()) parent_path=os.path.dirname(os.path.dirname(__file__)) # 获取上级目录 p_parent_path=os.path.dirname(os.path.dirname(os.path.dirname(__file__))) # 获取上上级目录 sys.path.append(parent_path) # 修改sys.path import other # 导入test下的other import packB.b1 # 导入b1 import \u0008packA.a2 #导入a2 import a2 # 此时sys.path既包含上级目录test也包含当前目录packA，所以跟上面一样  此外顺便提到os.getcwd()，注意该函数是获取当前终端的路径而不是脚本的路径，所以为了避免混淆，建议采用os.path.dirname(__file__)这样的形式。\n","date":1590222359,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1590222359,"objectID":"e09641fbd1bc631908120c416d39ef8b","permalink":"https://johnjim0816.github.io/may/23/6/saturday/144/post/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/","publishdate":"2020-05-23T16:25:59+08:00","relpermalink":"/may/23/6/saturday/144/post/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/","section":"post","summary":"import声明即用于导入模块，比如import numpy as np，但","tags":["python3"],"title":"深入了解import声明","type":"post"},{"authors":[],"categories":["野生技术"],"content":"为什么从Hexo转向Hugo Hexo优点很多，但缺点就是生成速度太慢。这是因为Hexo 基于 Nodejs ，有很多插件，而 Hugo 没有插件，使用自带的 Go html 模板实现。比如一般200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。\n快速开始 安装hugo brew install hugo  确认安装版本\nhugo version  新建站点 hugo new site blogs  这样会在当前目录下生成blog文件夹\n下载主题 cd blogs git clone add https://github.com/olOwOlo/hugo-theme-even.git theme/even  新建文章 hugo new post/test.md  本地运行 完成文章后，直接执行server命令启动\nhugo server  然后浏览器访问 http://localhost:1313/就可以看到内容\n更多主题 官网的主题：\nhttps://themes.gohugo.io/tags/documentation/\n个人觉得不错的：\n  Docsy\n超级完善的一个文档类主题， google出品，虽然不算是正式产品，特别适合做开源项目，强烈推荐。\nhttps://github.com/google/docsy\n  使用Academic主题搭建 Academic是一个特别适合搭建内容相对比较丰富的网站的主题，简洁大方，也适合作为一个稍有规模的正式网站。\n安装方式跟一般主题不太一样，但是我太喜欢，就暂停上面的快速开始，直接开始使用这个主题搭建吧。\n安装hugo brew install hugo  确认安装版本\nhugo version  安装站点(zip方式) Academic提供一个快速开始的站点模版Kickstart，[下载](https://github.com/sourcethemes/academic-kickstart/archive/master.zip) 并解压，  这一步跟快速搭建一节中的hugo new site blog是一样的性质，可以把解压后的文件夹academic-kickstart-master改名为blogs。\n除了zip之外更多方式参考 https://sourcethemes.com/academic/docs/install/\n安装主题  下载 并解压 Academic theme ，将里面的文件全部复制到上面创建的blogs/themes/academic文件夹中，注意这里已经将academic-kickstart-master改名为blogs。\n本地运行 cd到blogs目录， 执行hugo server，然后就可以在 http://localhost:1313/看到本地的默认网页。\n部署到Github Pages   在Github创建一个仓库，例如名字叫blogs，可以是私有的，这个仓库用来存放网站内容和源文件\n  再创建一个名称为\u0026lt;username\u0026gt;.github.io的仓库，\u0026lt;username\u0026gt;为GitHub用户名，这个仓库用于存放最终发布的网站内容\n  进入本地网站目录\ncd blogs    关联远程blogs仓库\ngit remote add origin git@github.com:\u0026lt;username\u0026gt;/blogs.git    将本地网站全部内容推送到远程blogs仓库\n注意(如有)先删除本地blogs目录下的public文件夹\ngit push -u origin master      创建public子模块\ngit submodule add -b master git@github.com:\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git public    执行hugo命令，网站静态内容就会生成到public文件夹，然后提交到远程blogs仓库，\nhugo cd public git status git add . git commit -m \u0026quot;first commit\u0026quot; git push -u orgin master    注：以上所有git操作都可以在VSCode中方便进行。\n另外更改config/_default/config.toml中的baseurl没改：\n# End your URL with a `/` trailing slash, e.g. `https://example.com/`. baseurl = \u0026quot;https://johnjim0816.github.io/\u0026quot;  Academic主题优化 可以参考 academic主题\n子主题风格 通过设置config/_default/params.toml中的theme变量更改，Academic主题提供了八种子主题，或者说风格，对应的本地文件在themes/academic/data/themes目录下。\n也可以 自定义主题，但我目前使用内置的1950s主题。\ntheme = \u0026quot;1950s\u0026quot;   使用时发现localhost主题生效，但是github pages却还是默认的绿色风格，然后发现是config/_default/config.toml中的baseurl没改：\n# End your URL with a `/` trailing slash, e.g. `https://example.com/`. baseurl = \u0026quot;https://johnjim0816.github.io/\u0026quot;   更改语言 修改config/_default/languages.toml，将对应的英文注释掉，并加上中文，暂不启用多语言版本：\n#[en] # languageCode = \u0026quot;en-us\u0026quot; [zh] languageCode = \u0026quot;zh-Hans\u0026quot;  此外修改config/_default/config.toml中的默认语言\ndefaultContentLanguage = \u0026quot;zh\u0026quot;  设置主页 Academic提供了一些默认选项，用来展示在首页的东西，包括Publications，Talks等，对应本地content/home/中的文件，如果不想展示，直接删掉或者在文件Front Matter处加入active=false，如下：\n--- active: false ---  其中个人或者作者简介对应content/home/about.md，而具体信息在content/authors/admin/_index.md中设置。\ncontact相关信息在config/_default/params.toml中\n增加目录 如果是增加顶部目录，只需要在文章内任意位置添加目录  为什么从Hexo转向Hugo 快速开始  安装hugo 新建站点 下载主题 新建文章 本地运行 更多主题   使用Academic主题搭建  安装hugo 安装站点(zip方式) 安装主题 本地运行 部署到Github Pages   Academic主题优化  子主题风格 更改语言 设置主页 增加目录   修改post默认模版 Refs  \n跟常见的[TOC]一样的效果。\n而增加侧边栏目录则需要更改single.html文件，具体参考 TOC for blog posts #1520中CharlieLeee的回答.\n修改post默认模版 具体模版文件在themes/academic/archetypes/post/index.md中\nRefs  浅谈我为什么从 HEXO 迁移到 HUGO\n 我为什么要从Hexo更换到Hugo\n https://gohugo.io/getting-started/quick-start/\n Academic官方文档\n hugo学习笔记\n Hugo部署到Github\n","date":1588830684,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1588830684,"objectID":"3a554b4f3511d978b627ecd1819da9a1","permalink":"https://johnjim0816.github.io/may/07/4/thursday/128/post/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/","publishdate":"2020-05-07T13:51:24+08:00","relpermalink":"/may/07/4/thursday/128/post/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/","section":"post","summary":"为什么从Hexo转向Hugo Hexo优点很多，但缺点就是生成","tags":["Hugo"],"title":"Hugo+github博客搭建笔记","type":"post"},{"authors":[],"categories":["野生技术"],"content":"写在前面 由于latex相关软件的编辑界面不太舒服，加上笔者钟情于VSCode，而网上没有一个简单易用的VSCode搭建教程，故有此书。\n编写latex的工具也多种多样，各有所爱，使用latex环境自带的编辑器固然无可厚非，然界面过于鄙陋，且无法实时编译预览，因而需要结合第三方文本编辑器，有结合ctex，有使用notepad++，而笔者更钟情于VSCode。VSCode的美妙无可言语，亦不多言，以下直接切入正题，如何使用VSCode编写latex，或者说搭建latex环境。\n安装Latex环境 Latex环境即Tex Live，见 参考链接1.1\n不同系统有不同的版本，并且还有完整版和简化版，这里给出全是不同系统完整版的传送门 MacTex下载链接 WIN上texlive可以现在在线安装版，也可以下载离线安装iso版本，由于网速问题，推荐下载离线iso的镜像 texlive iso清华镜像下载 texlive iso安装教程\nLaTeX Workshop 此乃VSCode插件，搜索安装即可，该插件的作用即将latex环境和第三方编辑器VSCode结合，使得在VSCode中能够调用latex环境。至于VSCode如何安装插件比较简单，可自查。\n设置settings.json(针对中文)  mac参考链接\nwin参考链接\n以上给出两个关于配置VSCode内settings.json的参考链接，实际上不管什么系统，配置都是一样的，如下： 快捷键cmd(ctrl)+shift+p输入setting打开settings.json把以下代码加入，注意在原本内容的最后一行加上英文逗号换行再复制粘贴，不然会报错\n此外如果需要支持中文路径下的文件，需要把以下内容中的%DOC%改为%DOCFILE%\u0026quot;，但此处笔者建议涉及代码方面不要用中文路径。\n\u0026quot;latex-workshop.view.pdf.viewer\u0026quot;: \u0026quot;tab\u0026quot;, \u0026quot;latex-workshop.latex.tools\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;xelatex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;xelatex\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-synctex=1\u0026quot;, \u0026quot;-interaction=nonstopmode\u0026quot;, \u0026quot;-file-line-error\u0026quot;, \u0026quot;-pdf\u0026quot;, \u0026quot;%DOC%\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;latexmk\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-synctex=1\u0026quot;, \u0026quot;-interaction=nonstopmode\u0026quot;, \u0026quot;-file-line-error\u0026quot;, \u0026quot;-pdf\u0026quot;, \u0026quot;%DOC%\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;pdflatex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;pdflatex\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-synctex=1\u0026quot;, \u0026quot;-interaction=nonstopmode\u0026quot;, \u0026quot;-file-line-error\u0026quot;, \u0026quot;%DOC%\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;bibtex\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;bibtex\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;%DOCFILE%\u0026quot; ] } ], \u0026quot;latex-workshop.latex.recipes\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;xelatex\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;xelatex\u0026quot; ] }, { \u0026quot;name\u0026quot;: \u0026quot;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex*2\u0026quot;, \u0026quot;tools\u0026quot;: [ \u0026quot;pdflatex\u0026quot;, \u0026quot;bibtex\u0026quot;, \u0026quot;pdflatex\u0026quot;, \u0026quot;pdflatex\u0026quot; ] } ]  demo 在 英文 路径下新建一个.tex文件，输入代码如下，注意首行\\documentclass[UTF8]{ctexart} 用于支持中文\n\\documentclass[UTF8]{ctexart} \\title{你好，world!} \\author{Winston} \\date{\\today} \\begin{document} \\maketitle 你好，world！ \\end{document}  然后cmd(ctrl)+s保存编译，就会生成.aux、.pdf等文件，注意保存的过程同时也是编译的过程，然后打开右上角预览就会看到生成的pdf\n","date":1587621084,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587621084,"objectID":"8b535cf6bbe4610697fb7ff4a01bcb25","permalink":"https://johnjim0816.github.io/april/23/4/thursday/114/post/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/","publishdate":"2020-04-23T13:51:24+08:00","relpermalink":"/april/23/4/thursday/114/post/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/","section":"post","summary":"写在前面 由于latex相关软件的编辑界面不太舒服，加上笔者钟","tags":["VSCode"],"title":"VSCode编写latex","type":"post"}]