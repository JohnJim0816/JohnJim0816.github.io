<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JohnJim&#39;s Blog</title>
    <link>https://johnjim0816.github.io/</link>
      <atom:link href="https://johnjim0816.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>JohnJim&#39;s Blog</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><lastBuildDate>Mon, 01 Jun 2020 16:28:35 +0800</lastBuildDate>
    <image>
      <url>https://johnjim0816.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>JohnJim&#39;s Blog</title>
      <link>https://johnjim0816.github.io/</link>
    </image>
    
    <item>
      <title>训练集(Train),验证集(Validation)和测试集(Test Sets)以及交叉验证法</title>
      <link>https://johnjim0816.github.io/june/01/1/monday/153/post/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/</link>
      <pubDate>Mon, 01 Jun 2020 16:28:35 +0800</pubDate>
      <guid>https://johnjim0816.github.io/june/01/1/monday/153/post/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/%E8%AE%AD%E7%BB%83%E9%9B%86train%E9%AA%8C%E8%AF%81%E9%9B%86validation%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86test-sets%E4%BB%A5%E5%8F%8A%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95/</guid>
      <description>&lt;p&gt;本文主要区分机器学习中的三种数据集，尤其是验证集和测试集，并介绍常用的交叉验证训练方法。&lt;/p&gt;
&lt;h2 id=&#34;training-set&#34;&gt;Training Set&lt;/h2&gt;
&lt;p&gt;训练集，即用于训练模型内参数(fit the model)的数据集。&lt;/p&gt;
&lt;h2 id=&#34;testing-set&#34;&gt;Testing Set&lt;/h2&gt;
&lt;p&gt;即测试集，在使用训练集调整参数之后，使用测试集来评价模型泛化能力。&lt;/p&gt;
&lt;h2 id=&#34;validation-set&#34;&gt;Validation Set&lt;/h2&gt;
&lt;p&gt;实际上使用测试集评价模型泛化能力之后并不意味着机器学习任务就此完成，最后还需要使用一个没有见过的数据集来判断模型是否work。在Kaggle中，Testing Set分为Public和Private Testing Set，Public就是用于评价模型泛化能力的通常意义上的测试集，而Private则是未知分布的测试集，决定最终排名的正是Private而不是Public测试。但是，通常训练好的模型在Public Testing Set上的error并不能代表模型在Private Testing Set上的error。例如，通过训练集训练出的model的error为0.1，那么在Public Testing Set中error一般大于且接近于0.1，而在Private Testing Set就不确定了，也可能大于0.5，也可能小于0.1。&lt;/p&gt;
&lt;p&gt;形象说来训练集就像是课本，学生通过课本学习知识，Public测试集就是平时的测验，而Private才是最终的高考。但是平时的测验往往只涵盖课本知识的一小部分，而高考则考查得更为全面，这也是为什么有些同学平时测验很好但是高考失常，平时较差但是高考成了黑马的原因之一。如何让Public测试集，即平时的测验变成有水准的模拟考试，从而反映学生在高考的水平呢？一种方法就是在学生学习课本知识的过程中增加平时作业。&lt;/p&gt;
&lt;p&gt;即可以从训练集中随机分出一部分作为验证集(Validation Set)，如下：
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200601163111113.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;
在训练集中调整参数以后，比如训练model1，model2，model3，将模型在验证集上测试，选出error最小的比如model1，然后用model1在整个Training Set上再训一次，然后使用Testing Set(Public)评价其泛化能力，这样此时在Testing Set(Public)上的结果就能跟最终的Private Testing Set相近了。&lt;/p&gt;
&lt;h2 id=&#34;交叉验证&#34;&gt;交叉验证&lt;/h2&gt;
&lt;p&gt;其实上面的验证集也只是从Training Set中抽出了一次，也就是只根据课本知识的某一部分布置了作业，想要得到最终好的结果就需要进行多组实验。交叉验证的做法就是将数据集分为近似均等且不相交的$k$份，如下：
$$
D=D_1 \or D_2 \or &amp;hellip; \or D_k \&lt;br&gt;
D_i \neq D_i (i \neq j)
$$&lt;/p&gt;
&lt;p&gt;然后依次取其中一份作为验证集，其余作为训练集进行训练，然后求得error的均值作为用于评价来调整模型参数，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200601163142503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入了解import声明</title>
      <link>https://johnjim0816.github.io/may/23/6/saturday/144/post/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sat, 23 May 2020 16:25:59 +0800</pubDate>
      <guid>https://johnjim0816.github.io/may/23/6/saturday/144/post/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3import%E5%A3%B0%E6%98%8E/</guid>
      <description>&lt;p&gt;import声明即用于导入模块，比如&lt;code&gt;import numpy as np&lt;/code&gt;，但是涉及复杂工程目录时容易搞得稀里糊涂，于是我专门使用了&lt;code&gt;python3.7&lt;/code&gt;来测试并解决import相关问题。&lt;/p&gt;
&lt;h2 id=&#34;基本定义&#34;&gt;基本定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;module&lt;/strong&gt;：即模块，也就是中各种&lt;code&gt;.py&lt;/code&gt;文件，模块名就是文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;built-in-module&lt;/strong&gt;：即内置模块，就是在安装python的时候系统编译在python解释器中的，比如&lt;code&gt;numpy&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;package&lt;/strong&gt;：任何包含&lt;code&gt;__init__.py&lt;/code&gt;文件的文件夹就是一个package。注意根据
&lt;a href=&#34;https://docs.python.org/3.7/reference/import.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;python document&lt;/a&gt;，在python3.3以上中，即使没有&lt;code&gt;__init__.py&lt;/code&gt;，文件夹也被自动视作一个package&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;object&lt;/strong&gt;：即对象，在python中，对象可以是函数，类以及变量等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;import与syspath&#34;&gt;import与sys.path&lt;/h2&gt;
&lt;p&gt;如果import导入了一个module，就能运行该module中的所有代码。导入package时，会运行package目录下的&lt;code&gt;__init__.py&lt;/code&gt;，然后通过&lt;code&gt;__init__.py&lt;/code&gt;运行package目录下的所有module，&lt;code&gt;__init__.py&lt;/code&gt;可以是空的，前面讲到在python3.3以上，&lt;code&gt;__init__.py&lt;/code&gt;可以没有。&lt;/p&gt;
&lt;p&gt;import会自动在&lt;code&gt;sys.path&lt;/code&gt;包含的目录中寻找相应的模块或者包，在一个&lt;code&gt;.py&lt;/code&gt;脚本被运行时，&lt;code&gt;sys.path&lt;/code&gt;会初始化包含以下目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PYTHONPATH&lt;/code&gt;，即常说的系统环境变量&lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认安装的模块目录，比如&lt;code&gt;numpy&lt;/code&gt;就在此目录中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.py&lt;/code&gt;脚本所在的目录，这一点根据脚本所在的目录不同是可以变化的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用的import方式&#34;&gt;常用的import方式&lt;/h2&gt;
&lt;p&gt;常用的import方式有四种：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import &amp;lt;package&amp;gt;

import &amp;lt;module&amp;gt;

from &amp;lt;package&amp;gt; import &amp;lt;module or subpackage or object&amp;gt;

from &amp;lt;module&amp;gt; import &amp;lt;object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然还有&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import &amp;lt;module&amp;gt; as   # 比如 import numpy as np
import &amp;lt;object&amp;gt; as
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;场景1导入系统以及同级目录下的模块&#34;&gt;场景1：导入系统以及同级目录下的模块&lt;/h2&gt;
&lt;p&gt;对于以下的工程目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test/                      # 跟目录
    packA/                 # package packA
        subA/              # subpackage subA
            __init__.py
            sa1.py
            sa2.py
        __init__.py
        a1.py
        a2.py
    packB/                 # package packB (implicit namespace package)
        b1.py
        b2.py
    other.py
    start.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要在&lt;code&gt;start.py&lt;/code&gt;中导入系统&lt;code&gt;numpy&lt;/code&gt;模块，以及同级目录下的&lt;code&gt;other&lt;/code&gt;模块，只需要：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy
import numpy as np # 通常将numpy重命名为np
import other
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运行&lt;code&gt;start.py&lt;/code&gt;脚本&lt;/p&gt;
&lt;h2 id=&#34;场景2导入子目录下的模块&#34;&gt;场景2:导入子目录下的模块&lt;/h2&gt;
&lt;p&gt;如果需要在&lt;code&gt;start.py&lt;/code&gt;中导入&lt;code&gt;a1.py&lt;/code&gt;，&lt;code&gt;b1.py&lt;/code&gt;以及&lt;code&gt;sa1.py&lt;/code&gt;模块，只需要在&lt;code&gt;start.py&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import packA.a1
import packB.b1
import packA.subA.sa1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果只需要导入比如&lt;code&gt;a1.py&lt;/code&gt;某个函数&lt;code&gt;a1_func()&lt;/code&gt;，只需要：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from packA.a1 import a1_func()
from packA.subA.sa1 import sa1_func() # 跟上面同理
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在&lt;code&gt;start.py&lt;/code&gt;和在&lt;code&gt;a1.py&lt;/code&gt;导入&lt;code&gt;sa1.py&lt;/code&gt;是不同的，在&lt;code&gt;a1.py&lt;/code&gt;需要：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import subA.sa1
from subA.sa1 import sa1_func()
from subA import sa2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为运行&lt;code&gt;a1.py&lt;/code&gt;时&lt;code&gt;sys.path&lt;/code&gt;的相应目录已经改变，只包含&lt;code&gt;a1.py&lt;/code&gt;脚本所在的目录。而对于python3，在&lt;code&gt;start.py&lt;/code&gt;是不能跨越子目录直接导入&lt;code&gt;sa1.py&lt;/code&gt;的，比如&lt;code&gt;from subA import sa1&lt;/code&gt;，但是在python2中可以，下面做个简单的总结：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运行&lt;/th&gt;
&lt;th&gt;from packA.subA import sa1&lt;/th&gt;
&lt;th&gt;from subA import sa1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;start.py&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;Py2 OK, Py3 fail (subA not in test/)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a1.py&lt;/td&gt;
&lt;td&gt;fail (packA not in test/packA/)&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;场景3导入父目录下的模块&#34;&gt;场景3:导入父目录下的模块&lt;/h2&gt;
&lt;p&gt;如果需要在&lt;code&gt;a1.py&lt;/code&gt;中导入父目录下&lt;code&gt;other.py&lt;/code&gt;或者是&lt;code&gt;packB&lt;/code&gt;目录下的&lt;code&gt;b1.py&lt;/code&gt;，此时就需要对&lt;code&gt;sys.path&lt;/code&gt;作出修改了，因为运行&lt;code&gt;a1.py&lt;/code&gt;时&lt;code&gt;sys.path&lt;/code&gt;包含&lt;code&gt;a1.py&lt;/code&gt;所在的目录&lt;code&gt;packA&lt;/code&gt;，并不包含目录&lt;code&gt;packB&lt;/code&gt;以及父目录&lt;code&gt;test&lt;/code&gt;。
修改&lt;code&gt;sys.path&lt;/code&gt;需要用到&lt;code&gt;sys&lt;/code&gt;以及&lt;code&gt;os&lt;/code&gt;模块，首先需要知道怎么获取当前目录以及父目录，在&lt;code&gt;a1.py&lt;/code&gt;中如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;current_path=os.path.dirname(__file__) #当前a1.py所在的目录packA 
parent_path=os.path.dirname(os.path.dirname(__file__)) #当前a1.py所在的父目录或者说上级目录test
p_parent_path=os.path.dirname(os.path.dirname(os.path.dirname(__file__))) ##获取上上级目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面修改&lt;code&gt;sys.path&lt;/code&gt;，对于在&lt;code&gt;a1.py&lt;/code&gt;中导入父目录下&lt;code&gt;other.py&lt;/code&gt;或者是&lt;code&gt;packB&lt;/code&gt;目录下的&lt;code&gt;b1.py&lt;/code&gt;，只需要将&lt;code&gt;parent_path&lt;/code&gt;加入到```sys.path``即可，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sys.path.append(parent_path)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以导入&lt;code&gt;other.py&lt;/code&gt;以及&lt;code&gt;b1.py&lt;/code&gt;了，完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
import os
# print(os.getcwd())
# sys.path.append(os.getcwd())
parent_path=os.path.dirname(os.path.dirname(__file__)) # 获取上级目录
p_parent_path=os.path.dirname(os.path.dirname(os.path.dirname(__file__))) # 获取上上级目录
sys.path.append(parent_path) # 修改sys.path
import other # 导入test下的other
import packB.b1 # 导入b1
import packA.a2 #导入a2
import a2 # 此时sys.path既包含上级目录test也包含当前目录packA，所以跟上面一样
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外顺便提到&lt;code&gt;os.getcwd()&lt;/code&gt;，注意该函数是获取当前终端的路径而不是脚本的路径，所以为了避免混淆，建议采用&lt;code&gt;os.path.dirname(__file__)&lt;/code&gt;这样的形式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo&#43;github博客搭建笔记</title>
      <link>https://johnjim0816.github.io/may/07/4/thursday/128/post/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 May 2020 13:51:24 +0800</pubDate>
      <guid>https://johnjim0816.github.io/may/07/4/thursday/128/post/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/hugo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;为什么从hexo转向hugo&#34;&gt;为什么从Hexo转向Hugo&lt;/h2&gt;
&lt;p&gt;Hexo优点很多，但缺点就是生成速度太慢。这是因为Hexo 基于 Nodejs ，有很多插件，而 Hugo 没有插件，使用自带的 Go html 模板实现。比如一般200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。&lt;/p&gt;
&lt;h2 id=&#34;快速开始&#34;&gt;快速开始&lt;/h2&gt;
&lt;h3 id=&#34;安装hugo&#34;&gt;安装hugo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install hugo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确认安装版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo version
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新建站点&#34;&gt;新建站点&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new site blogs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样会在当前目录下生成blog文件夹&lt;/p&gt;
&lt;h3 id=&#34;下载主题&#34;&gt;下载主题&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd blogs
git clone add https://github.com/olOwOlo/hugo-theme-even.git theme/even
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新建文章&#34;&gt;新建文章&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new post/test.md
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;本地运行&#34;&gt;本地运行&lt;/h3&gt;
&lt;p&gt;完成文章后，直接执行server命令启动&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后浏览器访问
&lt;a href=&#34;http://localhost:1313/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost:1313/&lt;/a&gt;就可以看到内容&lt;/p&gt;
&lt;h3 id=&#34;更多主题&#34;&gt;更多主题&lt;/h3&gt;
&lt;p&gt;官网的主题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://themes.gohugo.io/tags/documentation/&#34;&gt;https://themes.gohugo.io/tags/documentation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人觉得不错的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Docsy&lt;/p&gt;
&lt;p&gt;超级完善的一个文档类主题， google出品，虽然不算是正式产品，特别适合做开源项目，强烈推荐。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/google/docsy&#34;&gt;https://github.com/google/docsy&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用academic主题搭建&#34;&gt;使用Academic主题搭建&lt;/h2&gt;
&lt;p&gt;Academic是一个特别适合搭建内容相对比较丰富的网站的主题，简洁大方，也适合作为一个稍有规模的正式网站。&lt;/p&gt;
&lt;p&gt;安装方式跟一般主题不太一样，但是我太喜欢，就暂停上面的快速开始，直接开始使用这个主题搭建吧。&lt;/p&gt;
&lt;h3 id=&#34;安装hugo-1&#34;&gt;安装hugo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install hugo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确认安装版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo version
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装站点zip方式&#34;&gt;安装站点(zip方式)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Academic提供一个快速开始的站点模版Kickstart，[下载](https://github.com/sourcethemes/academic-kickstart/archive/master.zip) 并解压，
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一步跟快速搭建一节中的&lt;code&gt;hugo new site blog&lt;/code&gt;是一样的性质，可以把解压后的文件夹&lt;code&gt;academic-kickstart-master&lt;/code&gt;改名为&lt;code&gt;blogs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除了zip之外更多方式参考
&lt;a href=&#34;https://sourcethemes.com/academic/docs/install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://sourcethemes.com/academic/docs/install/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装主题&#34;&gt;安装主题&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/gcushen/hugo-academic/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载&lt;/a&gt; 并解压 &lt;em&gt;Academic theme&lt;/em&gt; ，将里面的文件全部复制到上面创建的&lt;code&gt;blogs/themes/academic&lt;/code&gt;文件夹中，注意这里已经将&lt;code&gt;academic-kickstart-master&lt;/code&gt;改名为&lt;code&gt;blogs&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;本地运行-1&#34;&gt;本地运行&lt;/h3&gt;
&lt;p&gt;cd到&lt;code&gt;blogs&lt;/code&gt;目录， 执行&lt;code&gt;hugo server&lt;/code&gt;，然后就可以在
&lt;a href=&#34;http://localhost:1313/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost:1313/&lt;/a&gt;看到本地的默认网页。&lt;/p&gt;
&lt;h3 id=&#34;部署到github-pages&#34;&gt;部署到Github Pages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在Github创建一个仓库，例如名字叫&lt;code&gt;blogs&lt;/code&gt;，可以是私有的，这个仓库用来存放网站内容和源文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再创建一个名称为&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;的仓库，&lt;code&gt;&amp;lt;username&amp;gt;&lt;/code&gt;为GitHub用户名，这个仓库用于存放最终发布的网站内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入本地网站目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd blogs
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关联远程blogs仓库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add origin git@github.com:&amp;lt;username&amp;gt;/blogs.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将本地网站全部内容推送到远程blogs仓库&lt;/p&gt;
&lt;p&gt;注意(如有)先删除本地&lt;code&gt;blogs&lt;/code&gt;目录下的&lt;code&gt;public&lt;/code&gt;文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push -u origin master  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建&lt;code&gt;public&lt;/code&gt;子模块&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule add -b master git@github.com:&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行&lt;code&gt;hugo&lt;/code&gt;命令，网站静态内容就会生成到&lt;code&gt;public&lt;/code&gt;文件夹，然后提交到远程blogs仓库，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo
cd public
git status
git add .
git commit -m &amp;quot;first commit&amp;quot;
git push -u orgin master
  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：以上所有git操作都可以在VSCode中方便进行。&lt;/p&gt;
&lt;p&gt;另外更改&lt;code&gt;config/_default/config.toml&lt;/code&gt;中的baseurl没改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# End your URL with a `/` trailing slash, e.g. `https://example.com/`.
baseurl = &amp;quot;https://johnjim0816.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;academic主题优化&#34;&gt;Academic主题优化&lt;/h2&gt;
&lt;p&gt;可以参考
&lt;a href=&#34;https://sourcethemes.com/academic/themes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;academic主题&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;子主题风格&#34;&gt;子主题风格&lt;/h3&gt;
&lt;p&gt;通过设置&lt;code&gt;config/_default/params.toml&lt;/code&gt;中的&lt;code&gt;theme&lt;/code&gt;变量更改，Academic主题提供了八种子主题，或者说风格，对应的本地文件在&lt;code&gt;themes/academic/data/themes&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;也可以
&lt;a href=&#34;https://sourcethemes.com/academic/docs/customization/#custom-theme&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义主题&lt;/a&gt;，但我目前使用内置的1950s主题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;theme = &amp;quot;1950s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;使用时发现localhost主题生效，但是github pages却还是默认的绿色风格，然后发现是&lt;code&gt;config/_default/config.toml&lt;/code&gt;中的baseurl没改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# End your URL with a `/` trailing slash, e.g. `https://example.com/`.
baseurl = &amp;quot;https://johnjim0816.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;更改语言&#34;&gt;更改语言&lt;/h3&gt;
&lt;p&gt;修改&lt;code&gt;config/_default/languages.toml&lt;/code&gt;，将对应的英文注释掉，并加上中文，暂不启用多语言版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;#[en]
#  languageCode = &amp;quot;en-us&amp;quot;

[zh]
  languageCode = &amp;quot;zh-Hans&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外修改&lt;code&gt;config/_default/config.toml&lt;/code&gt;中的默认语言&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;defaultContentLanguage = &amp;quot;zh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置主页&#34;&gt;设置主页&lt;/h3&gt;
&lt;p&gt;Academic提供了一些默认选项，用来展示在首页的东西，包括&lt;strong&gt;Publications&lt;/strong&gt;，&lt;strong&gt;Talks&lt;/strong&gt;等，对应本地&lt;code&gt;content/home/&lt;/code&gt;中的文件，如果不想展示，直接删掉或者在文件Front Matter处加入&lt;code&gt;active=false&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
active: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中个人或者作者简介对应&lt;code&gt;content/home/about.md&lt;/code&gt;，而具体信息在&lt;code&gt;content/authors/admin/_index.md&lt;/code&gt;中设置。&lt;/p&gt;
&lt;p&gt;contact相关信息在&lt;code&gt;config/_default/params.toml&lt;/code&gt;中&lt;/p&gt;
&lt;h3 id=&#34;增加目录&#34;&gt;增加目录&lt;/h3&gt;
&lt;p&gt;如果是增加顶部目录，只需要在文章内任意位置添加&lt;h2&gt;目录&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#为什么从hexo转向hugo&#34;&gt;为什么从Hexo转向Hugo&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#快速开始&#34;&gt;快速开始&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#安装hugo&#34;&gt;安装hugo&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#新建站点&#34;&gt;新建站点&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#下载主题&#34;&gt;下载主题&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#新建文章&#34;&gt;新建文章&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#本地运行&#34;&gt;本地运行&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#更多主题&#34;&gt;更多主题&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#使用academic主题搭建&#34;&gt;使用Academic主题搭建&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#安装hugo-1&#34;&gt;安装hugo&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#安装站点zip方式&#34;&gt;安装站点(zip方式)&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#安装主题&#34;&gt;安装主题&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#本地运行-1&#34;&gt;本地运行&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#部署到github-pages&#34;&gt;部署到Github Pages&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#academic主题优化&#34;&gt;Academic主题优化&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#子主题风格&#34;&gt;子主题风格&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#更改语言&#34;&gt;更改语言&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#设置主页&#34;&gt;设置主页&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#增加目录&#34;&gt;增加目录&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#修改post默认模版&#34;&gt;修改post默认模版&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#refs&#34;&gt;Refs&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;&lt;/p&gt;
&lt;p&gt;跟常见的&lt;code&gt;[TOC]&lt;/code&gt;一样的效果。&lt;/p&gt;
&lt;p&gt;而增加侧边栏目录则需要更改&lt;code&gt;single.html&lt;/code&gt;文件，具体参考
&lt;a href=&#34;https://github.com/gcushen/hugo-academic/issues/1520&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOC for blog posts #1520&lt;/a&gt;中&lt;code&gt;CharlieLeee&lt;/code&gt;的回答.&lt;/p&gt;
&lt;h2 id=&#34;修改post默认模版&#34;&gt;修改post默认模版&lt;/h2&gt;
&lt;p&gt;具体模版文件在&lt;code&gt;themes/academic/archetypes/post/index.md&lt;/code&gt;中&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://sspai.com/post/59904&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;浅谈我为什么从 HEXO 迁移到 HUGO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://dp2px.com/2019/08/30/go-hugo1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我为什么要从Hexo更换到Hugo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gohugo.io/getting-started/quick-start/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://sourcethemes.com/academic/docs/get-started/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Academic官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://skyao.io/learning-hugo/theme/theme.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hugo学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://jeshs.github.io/2019/01/hugo%e9%83%a8%e7%bd%b2%e5%88%b0github/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugo部署到Github&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VSCode编写latex</title>
      <link>https://johnjim0816.github.io/april/23/4/thursday/114/post/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/</link>
      <pubDate>Thu, 23 Apr 2020 13:51:24 +0800</pubDate>
      <guid>https://johnjim0816.github.io/april/23/4/thursday/114/post/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/vscode%E7%BC%96%E5%86%99latex/</guid>
      <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;由于latex相关软件的编辑界面不太舒服，加上笔者钟情于VSCode，而网上没有一个简单易用的VSCode搭建教程，故有此书。&lt;/p&gt;
&lt;p&gt;编写latex的工具也多种多样，各有所爱，使用latex环境自带的编辑器固然无可厚非，然界面过于鄙陋，且无法实时编译预览，因而需要结合第三方文本编辑器，有结合ctex，有使用notepad++，而笔者更钟情于VSCode。VSCode的美妙无可言语，亦不多言，以下直接切入正题，如何使用VSCode编写latex，或者说搭建latex环境。&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;安装latex环境&#34;&gt;安装Latex环境&lt;/h2&gt;
&lt;p&gt;Latex环境即Tex Live，见
&lt;a href=&#34;https://www.tug.org/texlive/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考链接1.1&lt;/a&gt;&lt;br&gt;
不同系统有不同的版本，并且还有完整版和简化版，这里给出全是不同系统完整版的传送门

&lt;a href=&#34;http://www.tug.org/mactex/mactex-download.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MacTex下载链接&lt;/a&gt;
WIN上texlive可以现在在线安装版，也可以下载离线安装iso版本，由于网速问题，推荐下载离线iso的镜像

&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/ctan/systems/texlive/Images/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;texlive iso清华镜像下载&lt;/a&gt;

&lt;a href=&#34;https://jingyan.baidu.com/article/4f34706e6e1c85e387b56dae.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;texlive iso安装教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;latex-workshop&#34;&gt;LaTeX Workshop&lt;/h2&gt;
&lt;p&gt;此乃VSCode插件，搜索安装即可，该插件的作用即将latex环境和第三方编辑器VSCode结合，使得在VSCode中能够调用latex环境。至于VSCode如何安装插件比较简单，可自查。&lt;/p&gt;
&lt;h2 id=&#34;设置settingsjson针对中文&#34;&gt;设置settings.json(针对中文)&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://blog.csdn.net/WinstonLau/article/details/89467446&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mac参考链接&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://zhuanlan.zhihu.com/p/38178015&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;win参考链接&lt;/a&gt;&lt;br&gt;
以上给出两个关于配置VSCode内settings.json的参考链接，实际上不管什么系统，配置都是一样的，如下：
快捷键cmd(ctrl)+shift+p输入setting打开settings.json把以下代码加入，注意在原本内容的最后一行加上英文逗号换行再复制粘贴，不然会报错&lt;/p&gt;
&lt;p&gt;此外如果需要支持中文路径下的文件，需要把以下内容中的%DOC%改为%DOCFILE%&amp;quot;，但此处笔者建议涉及代码方面不要用中文路径。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;latex-workshop.view.pdf.viewer&amp;quot;: &amp;quot;tab&amp;quot;,
    &amp;quot;latex-workshop.latex.tools&amp;quot;: [
      {
          &amp;quot;name&amp;quot;: &amp;quot;xelatex&amp;quot;,
          &amp;quot;command&amp;quot;: &amp;quot;xelatex&amp;quot;,
          &amp;quot;args&amp;quot;: [
              &amp;quot;-synctex=1&amp;quot;,
              &amp;quot;-interaction=nonstopmode&amp;quot;,
              &amp;quot;-file-line-error&amp;quot;,
              &amp;quot;-pdf&amp;quot;,
              &amp;quot;%DOC%&amp;quot;
          ]
      },
      {
          &amp;quot;name&amp;quot;: &amp;quot;latexmk&amp;quot;,
          &amp;quot;command&amp;quot;: &amp;quot;latexmk&amp;quot;,
          &amp;quot;args&amp;quot;: [
              &amp;quot;-synctex=1&amp;quot;,
              &amp;quot;-interaction=nonstopmode&amp;quot;,
              &amp;quot;-file-line-error&amp;quot;,
              &amp;quot;-pdf&amp;quot;,
              &amp;quot;%DOC%&amp;quot;
          ]
      },
      {
          &amp;quot;name&amp;quot;: &amp;quot;pdflatex&amp;quot;,
          &amp;quot;command&amp;quot;: &amp;quot;pdflatex&amp;quot;,
          &amp;quot;args&amp;quot;: [
              &amp;quot;-synctex=1&amp;quot;,
              &amp;quot;-interaction=nonstopmode&amp;quot;,
              &amp;quot;-file-line-error&amp;quot;,
              &amp;quot;%DOC%&amp;quot;
          ]
      },
      {
          &amp;quot;name&amp;quot;: &amp;quot;bibtex&amp;quot;,
          &amp;quot;command&amp;quot;: &amp;quot;bibtex&amp;quot;,
          &amp;quot;args&amp;quot;: [
              &amp;quot;%DOCFILE%&amp;quot;
          ]
      }
  ],
  &amp;quot;latex-workshop.latex.recipes&amp;quot;: [
      {
          &amp;quot;name&amp;quot;: &amp;quot;xelatex&amp;quot;,
          &amp;quot;tools&amp;quot;: [
              &amp;quot;xelatex&amp;quot;
          ]
      },
      {
          &amp;quot;name&amp;quot;: &amp;quot;pdflatex -&amp;gt; bibtex -&amp;gt; pdflatex*2&amp;quot;,
          &amp;quot;tools&amp;quot;: [
              &amp;quot;pdflatex&amp;quot;,
              &amp;quot;bibtex&amp;quot;,
              &amp;quot;pdflatex&amp;quot;,
              &amp;quot;pdflatex&amp;quot;
          ]
      }
  ]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;demo&#34;&gt;demo&lt;/h2&gt;
&lt;p&gt;在 &lt;strong&gt;英文&lt;/strong&gt; 路径下新建一个.tex文件，输入代码如下，注意首行\documentclass[UTF8]{ctexart} 用于支持中文&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\documentclass[UTF8]{ctexart} 
\title{你好，world!}
\author{Winston}
\date{\today}
\begin{document}
\maketitle
你好，world！
\end{document}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后cmd(ctrl)+s保存编译，就会生成.aux、.pdf等文件，注意保存的过程同时也是编译的过程，然后打开右上角预览就会看到生成的pdf&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
